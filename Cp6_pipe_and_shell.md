## 管道与shell

管道从根本上来说是一种在父子进程（大多数）间进行通信的方式，通过共享某个内存区域来完成，相比于IPC机制，优点在于直接共享，效率更高，
不依赖的进程的调度而缺点则在于会产生竞争等情况。Shell是我们允许程序的终端，其实编写一个足够实用的shell是一件非常有挑战性的工作，
我们在此其实做的只是一个Toy中的toy。

### Thinking 6.1
> 示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果
现在想让父进程作为“读者”，代码应当如何修改？    

非常简单的问题，关闭父进程读端，子进程写端再进行读取，其实即交换父子进程的功能代码。

### Thinking 6.2
> 上面这种不同步修改pp_ref 而导致的进程竞争问题在user/fd.c 中
的dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的dup 函数中为
什么会出现预想之外的情况？

不同修改造成的问题是，原本我们的判定条件是利用`pageref(rfd) + pageref(wfd) = pageref(pipe)`，当某个fd与pipe引用数相等时即某端关闭，
`dup`函数的功能是将旧文件标识符重定位到新文件标识符上，原本的`dup`先map文件标识符对应的内存，后map数据对应的内存（pipe），先增小的后增大的，
因而产生了竞争。

### Thinking 6.3
> 阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉
得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分
析

陷入系统调用时引发系统中断，此时时钟中断被屏蔽，不会产生进程间的切换，因而产生了原子性，如果有比系统调用中断更高级的中断产生，实际上它也不是原子的操作。

### Thingking 6.4
> * 按照上述说法控制pipeclose 中fd 和pipe unmap 的顺序，是否可以解决上
述场景的进程竞争问题？给出你的分析过程。
> * 我们只分析了close 时的情形，那么对于dup 中出现的情况又该如何解决？
请模仿上述材料写写你的理解。

可以解决，首先要注意到 pageref(pipe) >= pageref(fd), 接着当我们采取先减小值（通过规定顺序）的策略时，即使我们不能保证操作的原子性
但由于大小关系恒成立，因此不会出现误判等于的状况，dup中的情况是类似的，应该先增大值，达到同样的效果

### Issue
发现了一个指导书bug，已提交。

