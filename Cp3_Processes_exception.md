# 进程
  进程是对程序及其运行环境的抽象，通过保存它的上下文和当前状态，我们可以在进程间切换，达成同时运行多程序的目的。
  在本篇实验报告中，我觉得大多数细节指导书本身中已经说明得较为清楚，因此选择将注意力集中在思考题的解决上。

# 思考题
> #### Thinking 3.1
    为什么我们在构造空闲进程链表时使用了逆序插入的方式？
>    答：这其实只是一个约定，注释中写的较为明白，  
    使得第一个被分配出去的内存控制块就是envs数组中的第一个。  
    当然，也可以采用其他的约定。笔者实际编写时就使用了别的约定。

--------
> #### Thinking 3.2 思考env_ setup_ vm 函数：
  * **第三点注释中的问题**: 为什么我们要执行pgdir[i] = boot_pgdir[i]这个
赋值操作？换种说法，我们为什么要使用boot_pgdir作为一部分模板？(提
示:mips 虚拟空间布局)  
>  答：将一部分内核页表拷贝至用户进程的页表，其实是为了用户进程在进入内核态后（陷入内核）同样也能访问内核中的函数数据等。很多操作系统中都有类似的设计。
  * **UTOP 和ULIM 的含义分别是什么**，在UTOP 到ULIM 的区域与其他用户区
相比有什么最大的区别？
>  答： UTOP是用户可以使用的内存，ULIM是所有用户可以使用的内存和相关管理数据结构的和。这两个区域都是用户可视，并且通过页表访问。ULIM-UTOP最大区别在于，实际上它是由内核管理而非用户。
  * **(选做) 我们为什么要让pgdir[PDX(UVPT)]=env_cr3?**(提示: 结合系统自映射机制)
> 答： pgdir[PDX(UVPT)]指向的是指向页目录本身的页目录项, 所以要赋成相应的地址。

---------
> #### Thinking 3.3
  答：user_data 主要是提供个一个相对自由的用户参数。限制为特定类型自然也是可以的。但是设定为 `void *` 可以将多种这样的函数归一化供上层函数调用。举个例子，比如C标准库qsort函数传入的cmp指针就采用 `void *` 指针，而基于如此cmp函数的qsort可以不去关心底层的细节。

-------
> #### Thinking 3.4
  答： 1）虚拟空间，mips并没有实模式。
       2。应该是一样的，统一是为了操作系统对用户程序有一个统一的视图，可以使得相应加载程序简化。
       3. UTEXT起始附近。
--------

> #### Thinking 3.5
  答：应设置为TIMESTACK中epc的值。因为此时是通过中断来进行进程切换。保存的现场在中断处理程序中执行，pc值是无意义的，而epc值则保留了中断前执行的指令的pc地址，是我们所需要的。

---------
> #### Thinking 3.6
  TIMESTTACK：进程切换时的上下文保存区。
  SAVE_ALL函数在获取保存地址时，调用了get_sp

>        .macro get_sp
            mfc0    k1, CP0_CAUSE
            andi    k1, 0x107C
            xori    k1, 0x1000
            bnez    k1, 1f
            nop
            li      sp, 0x82000000
            j       2f
            nop
      1:
            bltz    sp, 2f
            nop
            lw      sp, KERNEL_SP
            nop

>      2:      nop
> 可以发现用于保存现场的地址是与中断原因有关的，在时钟中断切换时，则通过TIMESTACK保存现场，否则通过KENERL_SP。他们的意义不同也在于此。

-----------

> #### Thinking 3.7
    由于是需要轮询所有env控制块的调度算法。而时间片的中断是不管当前运行什么代码的。由于两个进程在envs数组内相邻。导致有一个进程的时间片中大量时间用于轮询，而另一个则无。因此造成了不公平。

>    如只有两个进程可以通过仅在这两进程间轮询的方式，有效保障公平。
